ğŸ”¥ Major Recursion Patterns
1. Subsequence / Subset Pattern

Definition: At each index, you decide â†’ take it OR skip it.

Examples:

Subset Sum 1 / 2

Combination Sum 1 / 2

Print all subsequences

Generate subsets (power set)

Clue in problem:

â€œFind all subsets/combinationsâ€

â€œCan you form this sum using elements?â€

Strategy:

Recursive tree â†’ choose or not choose.

Base case â†’ end of array/string.

Collect results in a list or count them.
-------------------------------------------------------------------------------------------------

2. Permutation Pattern

Definition: Fix one element â†’ recursively permute the rest.

Examples:

Print all permutations of string/array

Next Permutation problem

Clue in problem:

â€œAll possible orderings/arrangementsâ€

Strategy:

Swap elements or use visited[]

Recurse until all elements placed
--------------------------------------------------------------------------------------------------------------------

3. Partitioning Pattern

Definition: Break input into valid pieces.

Examples:

Palindrome Partitioning

Word Break

Clue in problem:

â€œSplit string/array into groups based on conditionâ€

Strategy:

At each index â†’ try all valid cuts

Recurse on remainder
--------------------------------------------------------------------------------------------------------------

4. Decision Tree (Game / Choices)

Definition: Try all possible moves, pick min/max.

Examples:

N-Queens

Sudoku solver

Rat in a Maze

Clue in problem:

â€œPlace item / make move / backtrack if invalidâ€

Strategy:

Place â†’ recurse â†’ undo (backtrack)
-----------------------------------------------------------------------------------------------------------------

5. Divide & Conquer

Definition: Split into smaller subproblems â†’ combine results.

Examples:

Merge Sort

Quick Sort

Binary Search

Clue in problem:

â€œDivide into halves and merge resultsâ€

Strategy:

Base case: single element

Recurse on halves, merge results
----------------------------------------------------------------------------------------------------------------------

6. DP-on-Recursion (Overlapping Subproblems)

Definition: Pure recursion but calls repeat â†’ add memoization.

Examples:

Fibonacci

Coin Change

Longest Common Subsequence (LCS)

Clue in problem:

â€œFind min/max ways/count/lengthâ€

Input sizes large (N up to 1000)

Strategy:

Write recursion â†’ add dp[n][m] to cache results
-------------------------------------------------------------------------------------------------------------------

ğŸ¯ How to Recognize Which Pattern

Subsequence/Subsets â†’ â€œtake or not take?â€

Permutation â†’ â€œall orderings/arrangements?â€

Partition â†’ â€œsplit input into valid chunks?â€

Backtracking/Decision â†’ â€œplace and check if valid?â€

Divide & Conquer â†’ â€œdivide halves and merge?â€

DP-on-Recursion â†’ â€œmin/max/count + overlapping subcalls?â€
-------------------------------------------------------------------------------------------------------------------

âš¡ Tackling Strategy

Write base case clearly â†’ when recursion should stop.

Make the choice â†’ pick element, skip element, swap element, cut string.

Recurse on remainder.

Backtrack if needed â†’ undo choice.

Optimize with memoization (if problem size large).
-------------------------------------------------------------------------------------------------------------------

ğŸ‘‰ Example: Subset Sum

Pattern: Subsequence (take/skip each number).

Base case: end of array.

Recurse: sum including this element + sum excluding it.

ğŸ‘‰ Example: Palindrome Partitioning

Pattern: Partition.

At each index: cut string if prefix is palindrome â†’ recurse on remainder.

ğŸ‘‰ Example: N-Queens

Pattern: Backtracking.

Place queen â†’ recurse next row â†’ backtrack if invalid.
