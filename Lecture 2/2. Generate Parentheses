Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Constraints:
1 <= n <= 8

----------------------------------------------------------------------------------------------------------
//Optimal solution

class Solution {
public:
    void recursion(int n, int open, int close, string s, vector<string>& ans){
        if(open+close == 2*n){
            ans.push_back(s);
            return;
        }
        if(open < n) recursion(n, open+1, close, s+'(', ans);
        if(close < open) recursion(n, open, close+1, s+')', ans);
    }

    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        recursion(n, 0, 0, "", ans);
        return ans;
    }
};
-------------------------------------------------------------------------------------------------------------
Method 1: Using Stack (Validation Approach)
#include <bits/stdc++.h>
using namespace std;

bool isValid(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == '(') st.push(c);
        else {
            if (st.empty()) return false;
            st.pop();
        }
    }
    return st.empty();
}

class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        int total = 1 << (2 * n); // all binary strings of length 2n
        for (int mask = 0; mask < total; mask++) {
            string s = "";
            for (int j = 2*n - 1; j >= 0; j--) {
                s += (mask & (1 << j)) ? '(' : ')';
            }
            if (isValid(s)) result.push_back(s);
        }
        return result;
    }
};

TC: O((2^2n) * n) (generate all + validate)
Very inefficient.
---------------------------------------------------------------------------------------------------------------------
Method 2: Recursion / Backtracking (Optimal)

TC : Catalan Number = 4^n/(n^(3/2) * pi^(1/2))
Generates only valid strings directly (optimal).
Best approach.
---------------------------------------------------------------------------------------------------------------------

Method 3: Bit Manipulation
class Solution {
public:
    bool isValid(string s) {
        int balance = 0;
        for (char c : s) {
            if (c == '(') balance++;
            else balance--;
            if (balance < 0) return false;
        }
        return balance == 0;
    }

    vector<string> generateParenthesis(int n) {
        vector<string> res;
        int total = 1 << (2*n);
        for (int mask = 0; mask < total; mask++) {
            string s;
            for (int j = 2*n-1; j >= 0; j--) {
                s += (mask & (1 << j)) ? '(' : ')';
            }
            if (isValid(s)) res.push_back(s);
        }
        return res;
    }
};

TC: O((2^2n) * n) (generate all + validate)
Very inefficient.
-------------------------------------------------------------------------------------------------------------------------
