Given an integer n, return all binary strings of length n that do not contain consecutive 1s. Return the result in lexicographically increasing order.

A binary string is a string consisting only of characters '0' and '1'.

Constraints:
1 <= n <= 20

-----------------------------------------------------------------------------------------------------------------------
//generating powerset using bit manipulation nad then checking-> 
//this works here because the constarints are very small-> 
//otherwise backtracking required


class Solution {
public:
    vector<string> generatePowerset(int n){
        vector<string> powerset;
        int total = 1<<n; //2^n possibilities
        for(int mask=0; mask<total; mask++){
            string s="";
            for(int j=n-1; j>=0; j--){
                if(mask&(1<<j)) s+= '1';
                else s+='0';
            }
            powerset.push_back(s);
        }
        return powerset;
    }

    vector<string> generateBinaryStrings(int n) {
        // Your code goes here
        vector<string> powerset = generatePowerset(n);
        vector<string> ans;

        for(auto &s : powerset){
            if(s.find("11") == string::npos){
                ans.push_back(s);
            }
        }
        sort(ans.begin(), ans.end());
        return ans; 
    }
};

------------------------------------------------------------------------------------------------------------------------

//backtracking approach
class Solution {
public:
    void backtrack(int n, string curr, vector<string> &result) {
        if ((int)curr.size() == n) { // base case
            result.push_back(curr);
            return;
        }

        // Option 1: Always can add '0'
        backtrack(n, curr + '0', result);

        // Option 2: Add '1' only if last char is not '1'
        if (curr.empty() || curr.back() == '0') {
            backtrack(n, curr + '1', result);
        }
    }

    vector<string> generateBinaryStrings(int n) {
        vector<string> result;
        backtrack(n, "", result);
        return result; // already lexicographic because we try '0' before '1'
    }
};
